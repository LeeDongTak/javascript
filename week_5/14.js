// 카운트 상태 변경 함수 #3
const increase = (function () {
    // 카운트 상태 변수
    let num = 0;
  
    // 클로저
    return function () {
      return ++num;
    };
  })();
  
  // 이전 상태값을 유지
  console.log(increase()); //1
  console.log(increase()); //2
  console.log(increase()); //3


// [코드 설명]
// 1. 위 코드가 실행되면 즉시 실행 함수가 호출되고 
// 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다.

// 2. increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된
// 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다
// 클로저 --> let num = 0을 기억한다

// 3. 즉시 실행 함수는 호출된 이후 소멸되지만, 즉시 실행 함수가 반환한
// 클로저는 increase 변수에 할당되어 호출된다.
// 결론 : num 은 초기화 x, 외부에수 접근할 수 없는 은닉된 값!!! 
// 의도치 않는 변경도 걱정할 필요 없음
// --> increase에서만 변경할 수 있기 때문에...!!

// 4. 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된
// 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다.

// 5. 따라서 즉시 실행 함수가 반환한 클로저는 카운트 상태를 유지하기 위한
// 자유 변수 num을 언제 어디서 호출하든지 참조하고 변경할 수 있다.

// 6. num은 초기화되지 않을 것이며, 외부에서 직접 접근할 수 없는 은닉된
// private 변수이므로, 전역 변수를 사용했을 때와 같이 의도되지 않은
// 변경을 걱정할 필요도 없다